#include <iostream>#include <vector>#include <climits>// Structure to represent an edge in the graphstruct Edge {    int u;  // Start vertex of the edge    int v;  // End vertex of the edge    int w;  // Weight of the edge (u, v)};// Structure to represent a graphstruct Graph {    int V;            // Total number of vertices in the graph    int E;            // Total number of edges in the graph    std::vector<Edge> edges;  // Vector of edges in the graph};// Function to initialize a graph with V vertices and E edgesGraph createGraph(int V, int E) {    return {V, E, std::vector<Edge>(E)};}// Function to print the solution arrayvoid printArr(const std::vector<int>& arr) {    for (int distance : arr) {        if (distance == INT_MAX)            std::cout << "INF ";        else            std::cout << distance << " ";    }    std::cout << std::endl;}// Bellman-Ford algorithm functionbool bellmanFord(const Graph& graph, int source) {    int V = graph.V;    int E = graph.E;    std::vector<int> dist(V, INT_MAX);  // Initialize distances with infinity    // Set distance of source vertex to itself as 0    dist[source] = 0;    // Relax all edges V-1 times    for (int i = 1; i <= V - 1; ++i) {        for (const Edge& edge : graph.edges) {            int u = edge.u;            int v = edge.v;            int w = edge.w;            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {                dist[v] = dist[u] + w;            }        }    }    // Check for negative cycles    for (const Edge& edge : graph.edges) {        int u = edge.u;        int v = edge.v;        int w = edge.w;        if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {            std::cout << "Graph contains negative weight cycle\n";            return false;        }    }    // Print the shortest distances from source    std::cout << "Shortest distances from source vertex " << source << " are:\n";    printArr(dist);    return true;}int main() {    // Input the number of vertices and edges    int V, E;    std::cout << "Enter the number of vertices and edges: ";    std::cin >> V >> E;    // Create a graph    Graph graph = createGraph(V, E);    // Input the edges of the graph    std::cout << "Enter the edges (start_vertex end_vertex weight):\n";    for (int i = 0; i < E; ++i) {        std::cin >> graph.edges[i].u >> graph.edges[i].v >> graph.edges[i].w;    }    // Input the source vertex    int source;    std::cout << "Enter the source vertex: ";    std::cin >> source;    // Run Bellman-Ford algorithm    bool result = bellmanFord(graph, source);    if (!result) {        std::cout << "No shortest paths exist due to negative weight cycle\n";    }    return 0;}