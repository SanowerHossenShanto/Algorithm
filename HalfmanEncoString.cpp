#include <iostream>#include <unordered_map>#include <queue>#include <vector>using namespace std;// A Huffman tree nodestruct HuffmanNode {    char data;    int frequency;    HuffmanNode *left, *right;    HuffmanNode(char data, int frequency) : data(data), frequency(frequency), left(nullptr), right(nullptr) {}};// Compare function for priority queuestruct Compare {    bool operator()(HuffmanNode* left, HuffmanNode* right) {        return left->frequency > right->frequency;    }};// Traverse the Huffman tree and assign codes to charactersvoid encode(HuffmanNode* root, string code, unordered_map<char, string>& huffmanCode) {    if (root == nullptr)        return;    if (!root->left && !root->right) {        huffmanCode[root->data] = code;    }    encode(root->left, code + "0", huffmanCode);    encode(root->right, code + "1", huffmanCode);}// Build Huffman tree and generate codesunordered_map<char, string> buildHuffmanTree(string text) {    unordered_map<char, int> frequencyMap;    for (char c : text) {        frequencyMap[c]++;    }    priority_queue<HuffmanNode*, vector<HuffmanNode*>, Compare> pq;    for (auto& entry : frequencyMap) {        pq.push(new HuffmanNode(entry.first, entry.second));    }    while (pq.size() != 1) {        HuffmanNode *left = pq.top(); pq.pop();        HuffmanNode *right = pq.top(); pq.pop();        HuffmanNode *internalNode = new HuffmanNode('\0', left->frequency + right->frequency);        internalNode->left = left;        internalNode->right = right;        pq.push(internalNode);    }    unordered_map<char, string> huffmanCode;    encode(pq.top(), "", huffmanCode);    return huffmanCode;}int main() {    string text;    cout << "Enter a string to encode: ";    getline(cin, text);    unordered_map<char, string> huffmanCode = buildHuffmanTree(text);    cout << "Huffman Codes:" << endl;    for (auto& entry : huffmanCode) {        cout << entry.first << " : " << entry.second << endl;    }    return 0;}