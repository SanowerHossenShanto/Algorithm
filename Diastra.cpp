#include <iostream>#include <vector>#include <algorithm>#include <climits>#define INT_MAX 10000000using namespace std;class Node;class Edge;void DijkstrasTest();int main() {    DijkstrasTest();    return 0;}class Node {public:    Node(char id) : id(id), previous(nullptr), distanceFromStart(INT_MAX) {}    char id;    Node* previous;    int distanceFromStart;};class Edge {public:    Edge(Node* node1, Node* node2, int distance) : node1(node1), node2(node2), distance(distance) {}    bool Connects(Node* node1, Node* node2) {        return (this->node1 == node1 && this->node2 == node2) ||               (this->node1 == node2 && this->node2 == node1);    }    Node* node1;    Node* node2;    int distance;};void Dijkstras();Node* ExtractSmallest(vector<Node*>& nodes);vector<Node*>* AdjacentRemainingNodes(Node* node);int Distance(Node* node1, Node* node2);bool Contains(vector<Node*>& nodes, Node* node);void PrintShortestRouteTo(Node* destination);vector<Node*> nodes;vector<Edge*> edges;void DijkstrasTest() {    Node* a = new Node('a');    Node* b = new Node('b');    Node* c = new Node('c');    Node* d = new Node('d');    Node* e = new Node('e');    Node* f = new Node('f');    Node* g = new Node('g');    Edge* e1 = new Edge(a, c, 1);    Edge* e2 = new Edge(a, d, 2);    Edge* e3 = new Edge(b, c, 2);    Edge* e4 = new Edge(c, d, 1);    Edge* e5 = new Edge(b, f, 3);    Edge* e6 = new Edge(c, e, 3);    Edge* e7 = new Edge(e, f, 2);    Edge* e8 = new Edge(d, g, 1);    Edge* e9 = new Edge(g, f, 1);    a->distanceFromStart = 0;  // set start node    Dijkstras();    PrintShortestRouteTo(f);}void Dijkstras() {    while (!nodes.empty()) {        Node* smallest = ExtractSmallest(nodes);        vector<Node*>* adjacentNodes = AdjacentRemainingNodes(smallest);        for (Node* adjacent : *adjacentNodes) {            int distance = Distance(smallest, adjacent) + smallest->distanceFromStart;            if (distance < adjacent->distanceFromStart) {                adjacent->distanceFromStart = distance;                adjacent->previous = smallest;            }        }        delete adjacentNodes;    }}Node* ExtractSmallest(vector<Node*>& nodes) {    Node* smallest = nodes.front();    for (Node* node : nodes) {        if (node->distanceFromStart < smallest->distanceFromStart) {            smallest = node;        }    }    nodes.erase(remove(nodes.begin(), nodes.end(), smallest), nodes.end());    return smallest;}vector<Node*>* AdjacentRemainingNodes(Node* node) {    vector<Node*>* adjacentNodes = new vector<Node*>();    for (Edge* edge : edges) {        Node* adjacent = nullptr;        if (edge->node1 == node) {            adjacent = edge->node2;        } else if (edge->node2 == node) {            adjacent = edge->node1;        }        if (adjacent && Contains(nodes, adjacent)) {            adjacentNodes->push_back(adjacent);        }    }    return adjacentNodes;}int Distance(Node* node1, Node* node2) {    for (Edge* edge : edges) {        if (edge->Connects(node1, node2)) {            return edge->distance;        }    }    return -1;  // should never happen}bool Contains(vector<Node*>& nodes, Node* node) {    return find(nodes.begin(), nodes.end(), node) != nodes.end();}void PrintShortestRouteTo(Node* destination) {    cout << "Shortest distance from start to " << destination->id << " is " << destination->distanceFromStart << endl;    cout << "Shortest route: ";    Node* current = destination;    while (current) {        cout << current->id << " ";        current = current->previous;    }    cout << endl;}