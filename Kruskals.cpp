#include <iostream>#include <vector>#include <algorithm>using namespace std;// Structure to represent an edge in the graphstruct Edge {    int src, dest, weight;};// Structure to represent a graphstruct Graph {    int V, E;    vector<Edge> edges;    // Constructor    Graph(int V, int E) {        this->V = V;        this->E = E;    }    // Function to add an edge to the graph    void addEdge(int src, int dest, int weight) {        edges.push_back({src, dest, weight});    }    // Function to find the parent of a node using path compression    int findParent(int parent[], int i) {        if (parent[i] != i)            parent[i] = findParent(parent, parent[i]);        return parent[i];    }    // Function to perform union of two sets by rank    void unionSets(int parent[], int rank[], int x, int y) {        int xRoot = findParent(parent, x);        int yRoot = findParent(parent, y);        if (rank[xRoot] < rank[yRoot])            parent[xRoot] = yRoot;        else if (rank[xRoot] > rank[yRoot])            parent[yRoot] = xRoot;        else {            parent[yRoot] = xRoot;            rank[xRoot]++;        }    }    // Function to find Minimum Spanning Tree using Kruskal's algorithm    int kruskalMST();};// Function to find Minimum Spanning Tree using Kruskal's algorithmint Graph::kruskalMST() {    int mstWeight = 0;    vector<Edge> result;    // Sort edges by weight    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {        return a.weight < b.weight;    });    int parent[V], rank[V];    for (int i = 0; i < V; i++) {        parent[i] = i;        rank[i] = 0;    }    // Iterate through sorted edges    for (const auto& edge : edges) {        int srcParent = findParent(parent, edge.src);        int destParent = findParent(parent, edge.dest);        // Check if including this edge does not form a cycle        if (srcParent != destParent) {            result.push_back(edge);            mstWeight += edge.weight;            unionSets(parent, rank, srcParent, destParent);        }    }    // Print the edges of the Minimum Spanning Tree    cout << "Edges of MST are:\n";    for (const auto& edge : result) {        cout << edge.src << " - " << edge.dest << " : " << edge.weight << endl;    }    return mstWeight;}int main() {    int V, E;    cout << "Enter the number of vertices and edges: ";    cin >> V >> E;    Graph graph(V, E);    cout << "Enter the edges (source, destination, weight):\n";    for (int i = 0; i < E; i++) {        int src, dest, weight;        cin >> src >> dest >> weight;        graph.addEdge(src, dest, weight);    }    int mstWeight = graph.kruskalMST();    cout << "\nWeight of MST is: " << mstWeight << endl;    return 0;}