#include <iostream>using namespace std;#define INF 999#define nV 4 // Assuming nV as a constantvoid printMatrix(int matrix[][nV], int n);// Implementing Floyd-Warshall algorithmvoid floydWarshall(int graph[][nV], int n) {    int matrix[nV][nV];    // Initialize matrix with the given graph    for (int i = 0; i < nV; i++)        for (int j = 0; j < nV; j++)            matrix[i][j] = graph[i][j];    // Adding vertices individually    for (int k = 0; k < nV; k++) {        for (int i = 0; i < nV; i++) {            for (int j = 0; j < nV; j++) {                if (matrix[i][k] + matrix[k][j] < matrix[i][j])                    matrix[i][j] = matrix[i][k] + matrix[k][j];            }        }    }    printMatrix(matrix, n);}// Function to print the resulting matrixvoid printMatrix(int matrix[][nV], int n) {    cout << "Resulting shortest paths matrix:" << endl;    for (int i = 0; i < n; i++) {        for (int j = 0; j < n; j++) {            if (matrix[i][j] == INF)                cout << "INF\t";            else                cout << matrix[i][j] << "\t";        }        cout << endl;    }}int main() {    int n;    cout << "Enter the number of vertices: ";    cin >> n;    int graph[nV][nV];    cout << "Enter the adjacency matrix (" << nV << "x" << nV << "):" << endl;    for (int i = 0; i < nV; i++) {        for (int j = 0; j < nV; j++) {            cin >> graph[i][j];            if (i != j && graph[i][j] == 0)                graph[i][j] = INF;        }    }    floydWarshall(graph, n);    return 0;}