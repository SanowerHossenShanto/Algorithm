#include <iostream>#include <list>#include <stack>#include <vector>using namespace std;class Graph {    int V;    vector<int> *adj;    void fillOrder(int v, vector<bool> &visited, stack<int> &Stack);    void DFS(int v, vector<bool> &visited);public:    Graph(int V);    void addEdge(int v, int w);    void printSCC();    Graph getTranspose();};Graph::Graph(int V) {    this->V = V;    adj = new vector<int>[V];}void Graph::DFS(int v, vector<bool> &visited) {    visited[v] = true;    cout << v << " ";    for (int u : adj[v]) {        if (!visited[u])            DFS(u, visited);    }}Graph Graph::getTranspose() {    Graph g(V);    for (int v = 0; v < V; v++) {        for (int u : adj[v]) {            g.adj[u].push_back(v);        }    }    return g;}void Graph::addEdge(int v, int w) {    adj[v].push_back(w);}void Graph::fillOrder(int v, vector<bool> &visited, stack<int> &Stack) {    visited[v] = true;    for (int u : adj[v]) {        if (!visited[u])            fillOrder(u, visited, Stack);    }    Stack.push(v);}void Graph::printSCC() {    stack<int> Stack;    vector<bool> visited(V, false);    for (int i = 0; i < V; i++) {        if (!visited[i])            fillOrder(i, visited, Stack);    }    Graph gr = getTranspose();    fill(visited.begin(), visited.end(), false);    while (!Stack.empty()) {        int v = Stack.top();        Stack.pop();        if (!visited[v]) {            gr.DFS(v, visited);            cout << endl;        }    }}int main() {    Graph g(8);    g.addEdge(0, 1);    g.addEdge(1, 2);    g.addEdge(2, 3);    g.addEdge(2, 4);    g.addEdge(3, 0);    g.addEdge(4, 5);    g.addEdge(5, 6);    g.addEdge(6, 4);    g.addEdge(6, 7);    cout << "Strongly Connected Components:\n";    g.printSCC();    return 0;}